# -----------------------------------------------------------------------------
# This file was autogenerated by symforce from template:
#     backends/python/templates/ops/CLASS/group_ops.py.jinja
# Do NOT modify by hand.
# -----------------------------------------------------------------------------

import math
import numpy
import typing as T

import sym  # pylint: disable=unused-import


class GroupOps(object):
    """
    Python GroupOps implementation for <class 'symforce.geo.rot3.Rot3'>.
    """

    @staticmethod
    def identity():
        # type: () -> sym.Rot3

        # Total ops: 0

        # Input arrays

        # Intermediate terms (0)

        # Output terms
        _res = [0.0] * 4
        _res[0] = 0
        _res[1] = 0
        _res[2] = 0
        _res[3] = 1
        return sym.Rot3.from_storage(_res)

    @staticmethod
    def inverse(a):
        # type: (sym.Rot3) -> sym.Rot3

        # Total ops: 3

        # Input arrays
        _a = a.data

        # Intermediate terms (0)

        # Output terms
        _res = [0.0] * 4
        _res[0] = -_a[0]
        _res[1] = -_a[1]
        _res[2] = -_a[2]
        _res[3] = _a[3]
        return sym.Rot3.from_storage(_res)

    @staticmethod
    def compose(a, b):
        # type: (sym.Rot3, sym.Rot3) -> sym.Rot3

        # Total ops: 28

        # Input arrays
        _a = a.data
        _b = b.data

        # Intermediate terms (0)

        # Output terms
        _res = [0.0] * 4
        _res[0] = _a[0] * _b[3] + _a[1] * _b[2] - _a[2] * _b[1] + _a[3] * _b[0]
        _res[1] = -_a[0] * _b[2] + _a[1] * _b[3] + _a[2] * _b[0] + _a[3] * _b[1]
        _res[2] = _a[0] * _b[1] - _a[1] * _b[0] + _a[2] * _b[3] + _a[3] * _b[2]
        _res[3] = -_a[0] * _b[0] - _a[1] * _b[1] - _a[2] * _b[2] + _a[3] * _b[3]
        return sym.Rot3.from_storage(_res)

    @staticmethod
    def between(a, b):
        # type: (sym.Rot3, sym.Rot3) -> sym.Rot3

        # Total ops: 28

        # Input arrays
        _a = a.data
        _b = b.data

        # Intermediate terms (0)

        # Output terms
        _res = [0.0] * 4
        _res[0] = -_a[0] * _b[3] - _a[1] * _b[2] + _a[2] * _b[1] + _a[3] * _b[0]
        _res[1] = _a[0] * _b[2] - _a[1] * _b[3] - _a[2] * _b[0] + _a[3] * _b[1]
        _res[2] = -_a[0] * _b[1] + _a[1] * _b[0] - _a[2] * _b[3] + _a[3] * _b[2]
        _res[3] = _a[0] * _b[0] + _a[1] * _b[1] + _a[2] * _b[2] + _a[3] * _b[3]
        return sym.Rot3.from_storage(_res)

    @staticmethod
    def inverse_with_jacobian(a):
        # type: (sym.Rot3) -> T.Tuple[sym.Rot3, numpy.ndarray]

        # Total ops: 45

        # Input arrays
        _a = a.data

        # Intermediate terms (13)
        _tmp0 = _a[0] ** 2
        _tmp1 = -_tmp0
        _tmp2 = _a[1] ** 2
        _tmp3 = _a[2] ** 2
        _tmp4 = _a[3] ** 2
        _tmp5 = _tmp3 - _tmp4
        _tmp6 = _a[2] * _a[3]
        _tmp7 = _a[0] * _a[1]
        _tmp8 = _a[1] * _a[3]
        _tmp9 = _a[0] * _a[2]
        _tmp10 = -_tmp2
        _tmp11 = _a[0] * _a[3]
        _tmp12 = _a[1] * _a[2]

        # Output terms
        _res = [0.0] * 4
        _res[0] = -_a[0]
        _res[1] = -_a[1]
        _res[2] = -_a[2]
        _res[3] = _a[3]
        _res_D_a = numpy.zeros((3, 3))
        _res_D_a[0, 0] = _tmp1 + _tmp2 + _tmp5
        _res_D_a[1, 0] = -2 * _tmp6 - 2 * _tmp7
        _res_D_a[2, 0] = 2 * _tmp8 - 2 * _tmp9
        _res_D_a[0, 1] = 2 * _tmp6 - 2 * _tmp7
        _res_D_a[1, 1] = _tmp0 + _tmp10 + _tmp5
        _res_D_a[2, 1] = -2 * _tmp11 - 2 * _tmp12
        _res_D_a[0, 2] = -2 * _tmp8 - 2 * _tmp9
        _res_D_a[1, 2] = 2 * _tmp11 - 2 * _tmp12
        _res_D_a[2, 2] = -_tmp1 - _tmp10 - _tmp3 - _tmp4
        return sym.Rot3.from_storage(_res), _res_D_a

    @staticmethod
    def compose_with_jacobians(a, b):
        # type: (sym.Rot3, sym.Rot3) -> T.Tuple[sym.Rot3, numpy.ndarray, numpy.ndarray]

        # Total ops: 148

        # Input arrays
        _a = a.data
        _b = b.data

        # Intermediate terms (54)
        _tmp0 = _a[0] * _b[3]
        _tmp1 = _a[2] * _b[1]
        _tmp2 = -_tmp1
        _tmp3 = _a[3] * _b[0]
        _tmp4 = _a[1] * _b[2]
        _tmp5 = _tmp3 + _tmp4
        _tmp6 = _tmp0 + _tmp2 + _tmp5
        _tmp7 = _a[2] * _b[0]
        _tmp8 = _a[1] * _b[3]
        _tmp9 = _a[3] * _b[1]
        _tmp10 = _a[0] * _b[2]
        _tmp11 = -_tmp10 + _tmp9
        _tmp12 = _tmp11 + _tmp7 + _tmp8
        _tmp13 = _a[2] * _b[3]
        _tmp14 = _a[1] * _b[0]
        _tmp15 = -_tmp14
        _tmp16 = _a[3] * _b[2]
        _tmp17 = _a[0] * _b[1]
        _tmp18 = _tmp16 + _tmp17
        _tmp19 = _tmp13 + _tmp15 + _tmp18
        _tmp20 = _a[3] * _b[3]
        _tmp21 = _a[0] * _b[0]
        _tmp22 = _a[2] * _b[2]
        _tmp23 = _a[1] * _b[1]
        _tmp24 = _tmp22 + _tmp23
        _tmp25 = _tmp20 - _tmp21 - _tmp24
        _tmp26 = -_tmp13
        _tmp27 = _tmp14 + _tmp18 + _tmp26
        _tmp28 = _tmp3 - _tmp4
        _tmp29 = _tmp0 + _tmp1 + _tmp28
        _tmp30 = -_tmp7
        _tmp31 = -_tmp8
        _tmp32 = _tmp11 + _tmp30 + _tmp31
        _tmp33 = _tmp20 - _tmp21
        _tmp34 = _tmp24 + _tmp33
        _tmp35 = -_tmp23
        _tmp36 = _tmp20 + _tmp21
        _tmp37 = _tmp22 + _tmp35 + _tmp36
        _tmp38 = _tmp10 + _tmp9
        _tmp39 = _tmp30 + _tmp38 + _tmp8
        _tmp40 = -_tmp0
        _tmp41 = _tmp1 + _tmp40 + _tmp5
        _tmp42 = _tmp16 - _tmp17
        _tmp43 = _tmp15 + _tmp26 + _tmp42
        _tmp44 = _tmp2 + _tmp28 + _tmp40
        _tmp45 = _tmp13 + _tmp14 + _tmp42
        _tmp46 = -_tmp22
        _tmp47 = _tmp23 + _tmp36 + _tmp46
        _tmp48 = _tmp31 + _tmp38 + _tmp7
        _tmp49 = _tmp33 + _tmp35 + _tmp46
        _tmp50 = _tmp12 ** 2 + _tmp19 ** 2 + _tmp25 * _tmp49 + _tmp6 ** 2
        _tmp51 = -_tmp19 * _tmp25 + _tmp19 * _tmp49
        _tmp52 = -_tmp12 * _tmp25 + _tmp12 * _tmp49
        _tmp53 = -_tmp25 * _tmp6 + _tmp49 * _tmp6

        # Output terms
        _res = [0.0] * 4
        _res[0] = _tmp6
        _res[1] = _tmp12
        _res[2] = _tmp19
        _res[3] = _tmp25
        _res_D_a = numpy.zeros((3, 3))
        _res_D_a[0, 0] = -_tmp12 * _tmp32 - _tmp19 * _tmp27 + _tmp25 * _tmp34 + _tmp29 * _tmp6
        _res_D_a[1, 0] = _tmp12 * _tmp29 - _tmp19 * _tmp34 - _tmp25 * _tmp27 + _tmp32 * _tmp6
        _res_D_a[2, 0] = _tmp12 * _tmp34 + _tmp19 * _tmp29 + _tmp25 * _tmp32 + _tmp27 * _tmp6
        _res_D_a[0, 1] = _tmp12 * _tmp41 + _tmp19 * _tmp37 + _tmp25 * _tmp43 + _tmp39 * _tmp6
        _res_D_a[1, 1] = _tmp12 * _tmp39 - _tmp19 * _tmp43 + _tmp25 * _tmp37 - _tmp41 * _tmp6
        _res_D_a[2, 1] = _tmp12 * _tmp43 + _tmp19 * _tmp39 - _tmp25 * _tmp41 - _tmp37 * _tmp6
        _res_D_a[0, 2] = -_tmp12 * _tmp47 + _tmp19 * _tmp44 - _tmp25 * _tmp48 + _tmp45 * _tmp6
        _res_D_a[1, 2] = _tmp12 * _tmp45 + _tmp19 * _tmp48 + _tmp25 * _tmp44 + _tmp47 * _tmp6
        _res_D_a[2, 2] = -_tmp12 * _tmp48 + _tmp19 * _tmp45 + _tmp25 * _tmp47 - _tmp44 * _tmp6
        _res_D_b = numpy.zeros((3, 3))
        _res_D_b[0, 0] = _tmp50
        _res_D_b[1, 0] = -_tmp51
        _res_D_b[2, 0] = _tmp52
        _res_D_b[0, 1] = _tmp51
        _res_D_b[1, 1] = _tmp50
        _res_D_b[2, 1] = -_tmp53
        _res_D_b[0, 2] = -_tmp52
        _res_D_b[1, 2] = _tmp53
        _res_D_b[2, 2] = _tmp50
        return sym.Rot3.from_storage(_res), _res_D_a, _res_D_b

    @staticmethod
    def between_with_jacobians(a, b):
        # type: (sym.Rot3, sym.Rot3) -> T.Tuple[sym.Rot3, numpy.ndarray, numpy.ndarray]

        # Total ops: 77

        # Input arrays
        _a = a.data
        _b = b.data

        # Intermediate terms (23)
        _tmp0 = -_a[0] * _b[3] - _a[1] * _b[2] + _a[2] * _b[1] + _a[3] * _b[0]
        _tmp1 = _a[0] * _b[2] - _a[1] * _b[3] - _a[2] * _b[0] + _a[3] * _b[1]
        _tmp2 = -_a[0] * _b[1] + _a[1] * _b[0] - _a[2] * _b[3] + _a[3] * _b[2]
        _tmp3 = _a[3] * _b[3]
        _tmp4 = _a[2] * _b[2]
        _tmp5 = _a[0] * _b[0]
        _tmp6 = _a[1] * _b[1]
        _tmp7 = _tmp1 ** 2
        _tmp8 = -_tmp7
        _tmp9 = _tmp0 ** 2
        _tmp10 = _tmp3 + _tmp4 + _tmp5 + _tmp6
        _tmp11 = _tmp10 ** 2
        _tmp12 = _tmp2 ** 2
        _tmp13 = _tmp11 - _tmp12
        _tmp14 = _tmp10 * _tmp2
        _tmp15 = _tmp0 * _tmp1
        _tmp16 = _tmp0 * _tmp2
        _tmp17 = _tmp1 * _tmp10
        _tmp18 = -_tmp9
        _tmp19 = _tmp0 * _tmp10
        _tmp20 = _tmp1 * _tmp2
        _tmp21 = _tmp11 + _tmp12
        _tmp22 = _tmp21 + _tmp7 + _tmp9

        # Output terms
        _res = [0.0] * 4
        _res[0] = _tmp0
        _res[1] = _tmp1
        _res[2] = _tmp2
        _res[3] = _tmp3 + _tmp4 + _tmp5 + _tmp6
        _res_D_a = numpy.zeros((3, 3))
        _res_D_a[0, 0] = -_tmp13 - _tmp8 - _tmp9
        _res_D_a[1, 0] = 2 * _tmp14 - 2 * _tmp15
        _res_D_a[2, 0] = -2 * _tmp16 - 2 * _tmp17
        _res_D_a[0, 1] = -2 * _tmp14 - 2 * _tmp15
        _res_D_a[1, 1] = -_tmp13 - _tmp18 - _tmp7
        _res_D_a[2, 1] = 2 * _tmp19 - 2 * _tmp20
        _res_D_a[0, 2] = -2 * _tmp16 + 2 * _tmp17
        _res_D_a[1, 2] = -2 * _tmp19 - 2 * _tmp20
        _res_D_a[2, 2] = -_tmp18 - _tmp21 - _tmp8
        _res_D_b = numpy.zeros((3, 3))
        _res_D_b[0, 0] = _tmp22
        _res_D_b[1, 0] = 0
        _res_D_b[2, 0] = 0
        _res_D_b[0, 1] = 0
        _res_D_b[1, 1] = _tmp22
        _res_D_b[2, 1] = 0
        _res_D_b[0, 2] = 0
        _res_D_b[1, 2] = 0
        _res_D_b[2, 2] = _tmp22
        return sym.Rot3.from_storage(_res), _res_D_a, _res_D_b
